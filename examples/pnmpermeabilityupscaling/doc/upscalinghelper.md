<!-- Important: This file has been automatically generated by generate_example_docs.py. Do not edit this file directly! -->


| [:arrow_left: Back to the main documentation](../README.md) | [:arrow_left: Go back to part 2](main.md) |
|---|---:|

# Part 3: Upscaling helper

The upscaling helper evaluates for each direction the pore-network simulation results and calculates the upscaled instrinsic permeability in this direction using:

```math
 K = v_\mathrm{Darcy} / \nabla p ~ \mu.
```
$`\nabla p`$ is a given pressure gradient and $`\mu`$ the fluid dynamic viscosity.

We evaluate the Darcy velocity as

```math
     v_\mathrm{Darcy} = \frac{q_\mathrm{mass,tot} / \varrho}{A_\mathrm{tot}}
```

where $`q_\mathrm{mass,tot}`$ is the total mass flow leaving the network over the REV's boundary with area
$`A_\mathrm{tot}`$. $`\varrho `$ is the fluid mass density.


The code documentation is structured as follows:

[[_TOC_]]


## Upscaling helper struct (`upscalinghelper.hh`)

This file contains the __upscaling helper struct__ which considers the volume flux leaving
the pore network in flow direction in order to find the upscaled Darcy permeability.

<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](../upscalinghelper.hh))</summary>


```cpp

namespace Dumux {

struct UpscalingHelper
{
```

### Calculate the intrinsic permeability
This function first evaluates the mass flux leaving the network in the direction of the applied pressure gradient.
Afterwards, the mass flux is converted into an area specify volume flux from which finally the intrinsic Darcy
permeability K [m^2] can be evaluated.

```cpp
    template<class Problem, class Scalar>
    static Scalar getDarcyPermeability(const Problem& problem, const Scalar totalMassFlux)
    {
        // get the domain side lengths from the problem
        auto sideLengths = problem.sideLengths();

        // create temporary stringstream with fixed scientifc formatting without affecting std::cout
        std::ostream tmp(std::cout.rdbuf());
        tmp << std::fixed << std::scientific;
        static constexpr char dirNames[] = "xyz";

        // convert mass to volume flux
        const auto volumeFlux = totalMassFlux / problem.liquidDensity();;

        sideLengths[problem.direction()] = 1.0;
        const auto outflowArea = std::accumulate(sideLengths.begin(), sideLengths.end(), 1.0, std::multiplies<Scalar>());
        const auto vDarcy = volumeFlux / outflowArea;
        const auto K = vDarcy / problem.pressureGradient() * problem.liquidDynamicViscosity();
        tmp << "\n########################################\n" << std::endl;
        tmp << dirNames[problem.direction()] << "-direction";
        tmp << ": Area = " << outflowArea << " m^2";
        tmp << "; Massflux = " << totalMassFlux << " kg/s";
        tmp << "; v_Darcy = " << vDarcy << " m/s";
        tmp << "; K = " << K << " m^2" << std::endl;
        tmp << "\n########################################\n" << std::endl;

        return K;
    }
```

### Determine the domain's side lengths automatically based on the bounding box of the network.

```cpp
    template<class GridGeometry>
    static auto getSideLengths(const GridGeometry& gridGeometry)
    {
        using GlobalPosition = typename GridGeometry::GlobalCoordinate;
        GlobalPosition result;

        std::cout << "Automatically determining side lengths of REV based on bounding box of pore network" << std::endl;
        for (int dimIdx = 0; dimIdx < GridGeometry::GridView::dimensionworld; ++dimIdx)
            result[dimIdx] = gridGeometry.bBoxMax()[dimIdx] - gridGeometry.bBoxMin()[dimIdx];

        return result;
    }
```


```cpp
};

} // end namespace Dumux
```


</details>


| [:arrow_left: Back to the main documentation](../README.md) | [:arrow_left: Go back to part 2](main.md) |
|---|---:|

